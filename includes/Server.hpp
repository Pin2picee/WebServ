#ifndef SERVER_HPP
# define SERVER_HPP

# include "Includes.hpp"

/**
 * @brief
 * A structure that will register the session infos of each client who generate a cookie.
 * 
 * @param current_page		The last web page the client connect to.
 * @param uploaded_files	The files the client uploaded.
 */
struct Session
{
	std::string ID;
    std::string current_page;
    std::vector<std::string> uploaded_files;
    time_t expiryTime;
};

/**
 * @brief
 * A global variable to save the sessions.
 * 
 * @param g_sessions	The sessions generated by cookies.
 */
extern std::map<std::string, Session> g_sessions;

/**
 * @brief
 * The structure that contains all the locations datas.
 * 
 * @param cgi			`true` if the cgi it's on, `false` if it's off.
 * @param autoindex		`true` if autoindex it's on, `false` if it's off.
 * @param root			The `Location` root path.
 * @param path			The `Location` extra path for datas. 
 * @param upload_dir	The directory where uploads are stored.
 * @param cgi_extension	The CGI file extension handled by this location.
 * @param methods		The list of allowed HTTP methods (e.g., GET, POST, DELETE).
 * @param index_files	The list of index files for this location.
 */
struct Locations
{
	bool						cgi;
	bool						autoindex;
	std::string					root;
	std::string					path;
	std::string					upload_dir;
	std::string					cgi_extension;
	std::vector<std::string>	methods;
	std::vector<std::string>	index_files;

	Locations()
		: cgi(false), autoindex(false),
		  root(RED "none"), path(RED "none"),
		  upload_dir(RED "none"), cgi_extension(RED "none") {}
};

struct Response;
struct Request;

/**
 * @brief
 * The class that contains all the `Server` datas.
 * 
 * @param root					The server root path.
 * @param listen				The canals to listen on.
 * @param locations				The `Location` datas.
 * @param error_pages			The error pages. 
 * @param client_max_body_size	The client max body size.
 */
class Server
{
private:
	std::string											root;
	std::vector<std::pair<std::string, int> >			listen;
	std::vector<Locations>								locations;
	std::map<int, std::string>							error_pages;
	size_t												client_max_body_size;

	void parseCGIOutput(Response &res, const std::string &output, Session &session) const;
public:
	Server();
	~Server();
	Server &operator=(const Server &assignement);
	Server(const Server &copy);
	// Getters

	const std::string&									getRoot() const;
	const std::vector<std::pair<std::string, int> >&	getListen() const;
	const std::vector<Locations>&						getLocations() const;
	const std::string&									getErrorPage(int code, Session &session) const;
	const std::map<int, std::string>&					getErrorPages() const;
	size_t												getClientMaxBodySize() const;

	// Modifiable getters

	std::vector<std::pair<std::string, int> >&			getListenRef();
	std::vector<Locations>&								getLocationsRef();
	std::map<int, std::string>&							getErrorPagesRef();

	// Setters

	void 												setRoot(const std::string &r);
	void 												setClientMaxBodySize(size_t value);

	// Utils

	void 												addLocation(const Locations& loc);
	void 												addListen(const std::string& ip, int port);
	void 												addErrorPage(int code, const std::string& path);
	void 												handleCGI(Response &res, const Request &req, const Locations &loc, Session &session) const;
};

Session	&getSession(const Request &req, Response &res);
void	removeUploadFileSession(Session &session, std::string deletePath);
void	deleteSession(void);

#endif
